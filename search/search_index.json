{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"KubeAI: Private Open AI on Kubernetes","text":"<p>Get inferencing running on Kubernetes: LLMs, Embeddings, Speech-to-Text.</p> <p>\u2705\ufe0f  Drop-in replacement for OpenAI with API compatibility \ud83e\udde0  Serve top OSS models (LLMs, Whisper, etc.) \ud83d\ude80  Multi-platform: CPU-only, GPU, coming soon: TPU \u2696\ufe0f  Scale from zero, autoscale based on load \ud83d\udee0\ufe0f  Zero dependencies (does not depend on Istio, Knative, etc.)  \ud83d\udcac  Chat UI included (OpenWebUI) \ud83e\udd16  Operates OSS model servers (vLLM, Ollama, FasterWhisper, Infinity) \u2709  Stream/batch inference via messaging integrations (Kafka, PubSub, etc.)  </p> <p>Quotes from the community:</p> <p>reusable, well abstracted solution to run LLMs - Mike Ensor</p>"},{"location":"#architecture","title":"Architecture","text":"<p>KubeAI serves an OpenAI compatible HTTP API. Admins can configure ML models via <code>kind: Model</code> Kubernetes Custom Resources. KubeAI can be thought of as a Model Operator (See Operator Pattern) that manages vLLM and Ollama servers.</p> <p></p>"},{"location":"#local-quickstart","title":"Local Quickstart","text":"<p>Create a local cluster using kind or minikube.</p> TIP: If you are using Podman for kind... Make sure your Podman machine can use up to 6G of memory (by default it is capped at 2G):  <pre><code># You might need to stop and remove the existing machine:\npodman machine stop\npodman machine rm\n\n# Init and start a new machine:\npodman machine init --memory 6144 --disk-size 120\npodman machine start\n</code></pre> <pre><code>kind create cluster # OR: minikube start\n</code></pre> <p>Add the KubeAI Helm repository.</p> <pre><code>helm repo add kubeai https://www.kubeai.org\nhelm repo update\n</code></pre> <p>Install KubeAI and wait for all components to be ready (may take a minute).</p> <pre><code>helm install kubeai kubeai/kubeai --wait --timeout 10m\n</code></pre> <p>Install some predefined models.</p> <pre><code>cat &lt;&lt;EOF &gt; kubeai-models.yaml\ncatalog:\n  gemma2-2b-cpu:\n    enabled: true\n    minReplicas: 1\n  qwen2-500m-cpu:\n    enabled: true\n  nomic-embed-text-cpu:\n    enabled: true\nEOF\n\nhelm install kubeai-models kubeai/models \\\n    -f ./kubeai-models.yaml\n</code></pre> <p>Before progressing to the next steps, start a watch on Pods in a standalone terminal to see how KubeAI deploys models. </p> <pre><code>kubectl get pods --watch\n</code></pre>"},{"location":"#interact-with-gemma2","title":"Interact with Gemma2","text":"<p>Because we set <code>minReplicas: 1</code> for the Gemma model you should see a model Pod already coming up.</p> <p>Start a local port-forward to the bundled chat UI.</p> <pre><code>kubectl port-forward svc/openwebui 8000:80\n</code></pre> <p>Now open your browser to localhost:8000 and select the Gemma model to start chatting with.</p>"},{"location":"#scale-up-qwen2-from-zero","title":"Scale up Qwen2 from Zero","text":"<p>If you go back to the browser and start a chat with Qwen2, you will notice that it will take a while to respond at first. This is because we set <code>minReplicas: 0</code> for this model and KubeAI needs to spin up a new Pod (you can verify with <code>kubectl get models -oyaml qwen2-500m-cpu</code>).</p> <p>NOTE: Autoscaling after initial scale-from-zero is not yet supported for the Ollama backend which we use in this local quickstart. KubeAI relies upon backend-specific metrics and the Ollama project has an open issue: https://github.com/ollama/ollama/issues/3144. To see autoscaling in action, checkout the GKE install guide which uses the vLLM backend and autoscales across GPU resources.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>Checkout our documentation on kubeai.org to find info on:</p> <ul> <li>Installing KubeAI in the cloud</li> <li>How to guides (e.g. how to manage models and resource profiles).</li> <li>Concepts (how the components of KubeAI work).</li> <li>How to contribute</li> </ul>"},{"location":"#adopters","title":"Adopters","text":"<p>List of known adopters:</p> Name Description Link Telescope Telescope uses KubeAI for multi-region large scale batch LLM inference. trytelescope.ai Google Cloud Distributed Edge KubeAI is included as a reference architecture for inferencing at the edge. LinkedIn, GitLab <p>If you are using KubeAI and would like to be listed as an adopter, please make a PR.</p>"},{"location":"#openai-api-compatibility","title":"OpenAI API Compatibility","text":"<pre><code># Implemented #\n/v1/chat/completions\n/v1/completions\n/v1/embeddings\n/v1/models\n/v1/audio/transcriptions\n\n# Planned #\n# /v1/assistants/*\n# /v1/batches/*\n# /v1/fine_tuning/*\n# /v1/images/*\n# /v1/vector_stores/*\n</code></pre>"},{"location":"#immediate-roadmap","title":"Immediate Roadmap","text":"<ul> <li>Model caching</li> <li>LoRA finetuning (compatible with OpenAI finetuning API)</li> <li>Image generation (compatible with OpenAI images API)</li> </ul> <p>NOTE: KubeAI was born out of a project called Lingo which was a simple Kubernetes LLM proxy with basic autoscaling. We relaunched the project as KubeAI (late August 2024) and expanded the roadmap to what it is today.</p> <p>\ud83c\udf1f Don't forget to drop us a star on GitHub and follow the repo to stay up to date!</p> <p></p>"},{"location":"#contact","title":"Contact","text":"<p>Let us know about features you are interested in seeing or reach out with questions. Visit our Discord channel to join the discussion!</p> <p>Or just reach out on LinkedIn if you want to connect:</p> <ul> <li>Nick Stogner</li> <li>Sam Stoelinga</li> </ul>"},{"location":"concepts/autoscaling/","title":"Autoscaling","text":"<p>KubeAI proxies HTTP and messaging (i.e. Kafka, etc) requests and messages to models. It will adjust the number Pods serving a given model based on metrics reported by those servers. If no Pods are running when a request comes in, KubeAI will hold the request, scale up a Pod and forward the request when the Pod is ready. This process happens in a manner that is transparent to the end client (other than the added delay from a cold-start).</p> <p> </p>"},{"location":"concepts/autoscaling/#next","title":"Next","text":"<p>Read about how to configure autoscaling.</p>"},{"location":"concepts/backend-servers/","title":"Backend Servers","text":"<p>KubeAI serves ML models by launching Pods on Kubernetes. The configuration and lifecycle of these Pods are managed by the KubeAI controller. Every model server Pod loads exactly one model on startup.</p> <p>In a Model manifest you can define what server to use for inference (<code>VLLM</code>, <code>OLlama</code>). Any model-specific settings can be passed to the server process via the <code>args</code> and <code>env</code> fields.</p>"},{"location":"concepts/backend-servers/#next","title":"Next","text":"<p>Read about how to install models.</p>"},{"location":"concepts/resource-profiles/","title":"Resource Profiles","text":"<p>A resource profile maps a type of compute resource (i.e. NVIDIA L4 GPU) to a collection of Kubernetes settings that are configured on inference server Pods. These profiles are defined in the KubeAI <code>config.yaml</code> file (via a ConfigMap). Each model specifies the resource profile that it requires.</p> <p>Kubernetes Model resources specify a resource profile and the count of that resource that they require (for example <code>resourceProfile: nvidia-gpu-l4:2</code> - 2x L4 GPUs).</p> <p>A given profile might need to contain slightly different settings based on the cluster/cloud that KubeAI is deployed in.</p> <p>Example: A resource profile named <code>nvidia-gpu-l4</code> might contain the following node selectors when installing KubeAI on a GKE Kubernetes cluster:</p> <pre><code>cloud.google.com/gke-accelerator: \"nvidia-l4\"\ncloud.google.com/gke-spot: \"true\"\n</code></pre> <p>and add the following resource requests to the model server Pods:</p> <pre><code>nvidia.com/gpu: \"1\"\n</code></pre> <p>In addition to node selectors and resource requirements, a resource profile may optionally specify an image name. This name maps to the container image that will be selected when serving a model on that resource.</p>"},{"location":"concepts/resource-profiles/#next","title":"Next","text":"<p>Read about how to configure resource profiles.</p>"},{"location":"concepts/storage-caching/","title":"Storage / Caching","text":"<p>With \"Large\" in the name, caching is a critical part of serving LLMs.</p> <p>The best caching technique may very depending on your environment:</p> <ul> <li>What cloud features are available?</li> <li>Is your cluster deployed in an air-gapped environment?</li> </ul>"},{"location":"concepts/storage-caching/#a-model-built-into-container","title":"A. Model built into container","text":"<p>Status: Supported</p> <p>Building a model into a container image can provide a simple way to take advantage of image-related optimizations built into Kubernetes:</p> <ul> <li> <p>Relaunching a model server on the same Node that it ran on before will likely be able to reuse the previously pulled image.</p> </li> <li> <p>Secondary boot disks on GKE can be used to avoid needing to pull images.</p> </li> <li> <p>Image streaming on GKE can allow for containers to startup before the entire image is present on the Node.</p> </li> <li> <p>Container images can be pre-installed on Nodes in air-gapped environments (example: k3s airgap installation).</p> </li> </ul> <p>Guides:</p> <ul> <li>How to build models into container images</li> </ul>"},{"location":"concepts/storage-caching/#b-model-on-shared-filesystem-read-write-many","title":"B. Model on shared filesystem (read-write-many)","text":"<p>Status: Planned.</p> <p>Examples: AWS EFS</p>"},{"location":"concepts/storage-caching/#c-model-on-read-only-many-disk","title":"C. Model on read-only-many disk","text":"<p>Status: Planned.</p> <p>Examples: GCP Hyperdisk ML</p>"},{"location":"contributing/development-environment/","title":"Development environment","text":"<p>This document provides instructions for setting up an environment for developing KubeAI.</p>"},{"location":"contributing/development-environment/#optional-cloud-setup","title":"Optional: Cloud Setup","text":""},{"location":"contributing/development-environment/#gcp-pubsub","title":"GCP PubSub","text":"<p>If you are develop PubSub messaging integration on GCP, setup test topics and subscriptions and uncomment the <code>.messaging.streams</code> in <code>./hack/dev-config.yaml</code>.</p> <pre><code>gcloud auth login --update-adc\n\ngcloud pubsub topics create test-kubeai-requests\ngcloud pubsub subscriptions create test-kubeai-requests-sub --topic test-kubeai-requests\ngcloud pubsub topics create test-kubeai-responses\ngcloud pubsub subscriptions create test-kubeai-responses-sub --topic test-kubeai-responses\n</code></pre>"},{"location":"contributing/development-environment/#run-in-local-cluster","title":"Run in Local Cluster","text":"<pre><code>kind create cluster\n# OR\n#./hack/create-dev-gke-cluster.yaml\n\n# Generate CRDs from Go code.\nmake generate &amp;&amp; make manifests\n\n# When CRDs are changed reapply using kubectl:\nkubectl apply -f ./charts/kubeai/charts/crds/crds\n\n# Model with special address annotations:\nkubectl apply -f ./hack/dev-model.yaml\n\n# OPTION A #\n# Run KubeAI inside cluster\n# Change `-f` based on the cluster environment.\nhelm upgrade --install kubeai ./charts/kubeai \\\n    --set openwebui.enabled=true \\\n    --set image.tag=latest \\\n    --set image.pullPolicy=Always \\\n    --set image.repository=us-central1-docker.pkg.dev/substratus-dev/default/kubeai \\\n    --set secrets.huggingface.token=$HUGGING_FACE_HUB_TOKEN \\\n    --set replicaCount=1 -f ./hack/dev-gke-helm-values.yaml\n\n# OPTION B #\n# For quick local interation (run KubeAI outside of cluster)\nCONFIG_PATH=./hack/dev-config.yaml POD_NAMESPACE=default go run ./cmd/main.go\n\n# In another terminal:\nwhile true; do kubectl port-forward service/dev-model 7000:7000; done\n############\n</code></pre>"},{"location":"contributing/development-environment/#running","title":"Running","text":""},{"location":"contributing/development-environment/#completions-api","title":"Completions API","text":"<pre><code># If you are running kubeai in-cluster:\n# kubectl port-forward svc/kubeai 8000:80\n\ncurl http://localhost:8000/openai/v1/completions -H \"Content-Type: application/json\" -d '{\"prompt\": \"Hi\", \"model\": \"dev\"}' -v\n</code></pre>"},{"location":"contributing/development-environment/#messaging-integration","title":"Messaging Integration","text":"<pre><code>gcloud pubsub topics publish test-kubeai-requests \\                  \n  --message='{\"path\":\"/v1/completions\", \"metadata\":{\"a\":\"b\"}, \"body\": {\"model\": \"dev\", \"prompt\": \"hi\"}}'\n\ngcloud pubsub subscriptions pull test-kubeai-responses-sub --auto-ack\n</code></pre>"},{"location":"contributing/documentation/","title":"Documentation","text":"<p>We are grateful for anyone who takes the time to improve KubeAI documentation! In order to keep our docs clear and consistent we ask that you first read about the approach to documentation that we have standardized on...</p>"},{"location":"contributing/documentation/#read-before-writing","title":"Read before writing!","text":"<p>The KubeAI approach to documentation is loosely inspired by the Diataxis method.</p> <p>TLDR on how KubeAI docs are organized:</p> <ul> <li>Installation: How-to guides specific to installing KubeAI.</li> <li>How To: Directions that guide the reader through a problem or towards a result. How-to guides are goal-oriented. They assume the user is familiar with general concepts, tools, and has already installed KubeAI.</li> <li>Concepts: A reflective explanation of KubeAI topics with a focus on giving the reader an understanding of the why.</li> <li>Tutorials: Learning oriented experiences. Lessons that often guide a user from beginning to end. The goal is to help the reader learn something (compared to a how-to guide that is focused on helping the reader do something).</li> <li>Contributing: The docs in here differ from the rest of the docs by audience: these docs are for anyone who will be contributing code or docs to the KubeAI project.</li> </ul>"},{"location":"contributing/documentation/#how-to-serve-kubeaiorg-locally","title":"How to serve kubeai.org locally","text":"<p>Make sure you have python3 installed and run:</p> <pre><code>make docs\n</code></pre>"},{"location":"contributing/release-process/","title":"Release Process","text":"<p>This document describes the process for releasing a new version of the project.</p>"},{"location":"contributing/release-process/#docs","title":"Docs","text":"<p>The docs are automatically published whenever a PR updates the docs and the PR is merged into the main branch. The docs are published to the <code>gh-pages</code> branch, which is the source for the Github Pages site.</p>"},{"location":"contributing/release-process/#docker-images","title":"Docker images","text":"<p>The Docker image latest tag always points to the latest released version. The <code>main</code> tag points to the latest commit on the main branch.</p> <p>If you push a tag <code>vX.Y.Z</code> to the repository, the Docker image with the tag <code>vX.Y.Z</code> is built and pushed to Docker Hub. Afterwards, the <code>latest</code> tag is updated to point to the new version.</p>"},{"location":"contributing/release-process/#helm-chart","title":"Helm Chart","text":"<p>The Helm chart only gets released when a git tag is pushed to the repository with the format <code>helm-v*</code>.</p> <p>The appVersion in the Helm chart does not have to point to the latest released version. This allows us to first publish a new version of the Docker image without updating the Helm chart. The Helm chart is updated when we are ready to release a new version.</p> <p>This is important when a new appVersion isn't compatible with the current Helm chart. In those cases, we can first merge the PR, thoroughly test, release new container image, and then in a separate PR update the Helm chart and the appVersion.</p>"},{"location":"how-to/build-models-into-containers/","title":"Build models into containers","text":"<p>In this guide we will preload a LLM into a custom built Ollama serving image. You can follow the same steps for other models and other serving engines.</p> <p>Define some values <pre><code>export MODEL_URL=ollama://qwen2:0.5b\n\n# Customize with your own image repo.\nexport IMAGE=us-central1-docker.pkg.dev/substratus-dev/default/ollama-builtin-qwen2-05b:latest\n</code></pre></p> <p>Build and push image. Note: building (downloading base image &amp; model) and pushing (uploading image &amp; model) can take a while depending on the size of the model.</p> <pre><code>git clone https://github.com/substratusai/kubeai\ncd ./kubeai/images/ollama-builtin\n\ndocker build --build-arg MODEL_URL=$MODEL_URL -t $IMAGE .\ndocker push $IMAGE\n</code></pre> <p>Create a model manifest &amp; apply into a cluster with KubeAI installed. NOTE: The only difference between an built-in model image and otherwise is the addition of the <code>image:</code> field.</p> <pre><code>kubectl apply -f - &lt;&lt; EOF\napiVersion: kubeai.org/v1\nkind: Model\nmetadata:\n  name: builtin-model-example\nspec:\n  features: [\"TextGeneration\"]\n  owner: alibaba\n  image: $IMAGE # &lt;-- The image with model built-in\n  url: \"$MODEL_URL\"\n  engine: OLlama\n  resourceProfile: cpu:1\nEOF\n</code></pre>"},{"location":"how-to/configure-autoscaling/","title":"Configure autoscaling","text":"<p>This guide with cover how to configure KubeAI autoscaling parameters.</p>"},{"location":"how-to/configure-autoscaling/#system-settings","title":"System Settings","text":"<p>KubeAI administrators can define system-wide autoscaling settings by setting the following Helm values (for the <code>kubeai/kubeai</code> chart):</p> <p>Example:</p> <pre><code># helm-values.yaml\nmodelAutoscaling:\n  interval: 15s\n  timeWindow: 10m\n# ...\n</code></pre>"},{"location":"how-to/configure-autoscaling/#model-settings","title":"Model Settings","text":"<p>The following settings can be configured on a model-by-model basis.</p> <p>NOTE: Updates to model settings will be applied upon scale up of additional model Pods. You can force-restart model servers by running <code>kubectl delete pods -l model=&lt;model-name&gt;</code>.</p>"},{"location":"how-to/configure-autoscaling/#model-settings-helm","title":"Model settings: helm","text":"<p>If you are managing models via the <code>kubeai/models</code> Helm chart, you can use:</p> <pre><code># helm-values.yaml\ncatalog:\n  model-a:\n    # ...\n    minReplicas: 1\n    maxReplicas: 9\n    targetRequests: 250\n    scaleDownDelaySeconds: 45\n  model-b:\n    # ...\n    disableAutoscaling: true\n# ...\n</code></pre> <p>Re-running <code>helm upgrade</code> with these additional parameters will update model settings in the cluster.</p>"},{"location":"how-to/configure-autoscaling/#model-settings-kubectl","title":"Model settings: kubectl","text":"<p>You can also specify the autoscaling profile directly via the Models custom resource in the Kubernetes API:</p> <pre><code>apiVersion: kubeai.org/v1\nkind: Model\nmetadata:\n  name: my-model\nspec:\n  # ...\n  minReplicas: 1\n  maxReplicas: 9\n  targetRequests: 250\n  scaleDownDelaySeconds: 45\n</code></pre> <p>If you are already managing models using Model manifest files, you can make the update to your file and reapply it using <code>kubectl apply -f &lt;filename&gt;.yaml</code>.</p>"},{"location":"how-to/configure-embedding-models/","title":"Configure Embedding Models","text":"<p>KubeAI supports the following engines for text embedding models:</p> <ul> <li>Infinity</li> <li>vLLM</li> <li>Ollama</li> </ul> <p>Infinity supports any HuggingFace models listed as text-embedding. See the models, reranking or clip models on huggingface for reference.</p>"},{"location":"how-to/configure-embedding-models/#install-baaibge-small-en-v15-model-using-infinity","title":"Install BAAI/bge-small-en-v1.5 model using Infinity","text":"<p>Create a file named <code>kubeai-models.yaml</code> with the following content:</p> <pre><code>catalog:\n  bge-embed-text-cpu:\n    enabled: true\n    features: [\"TextEmbedding\"]\n    owner: baai\n    url: \"hf://BAAI/bge-small-en-v1.5\"\n    engine: Infinity\n    resourceProfile: cpu:1\n    minReplicas: 1\n</code></pre> <p>Apply the kubeai-models helm chart:</p> <pre><code>helm install kubeai-models kubeai/models -f ./kubeai-models.yaml\n</code></pre> <p>Once the pod is ready, you can use the OpenAI Python SDK to interact with the model:</p> <pre><code>from openai import OpenAI\n# Assumes port-forward of kubeai service to localhost:8000.\nclient = OpenAI(api_key=\"ignored\", base_url=\"http://localhost:8000/openai/v1\")\nresponse = client.embeddings.create(\n    input=\"Your text goes here.\",\n    model=\"bge-embed-text-cpu\"\n)\n</code></pre>"},{"location":"how-to/configure-resource-profiles/","title":"Configure resource profiles","text":"<p>This guide will cover modifying preconfigured resource profiles and adding your own.</p>"},{"location":"how-to/configure-resource-profiles/#modifying-preconfigured-resource-profiles","title":"Modifying preconfigured resource profiles","text":"<p>The KubeAI helm chart comes with preconfigured resource profiles for common resource types such as NVIDIA L4 GPUs. You can view these profiles in the default helm values file.</p> <p>These profiles usually require some additional settings based on the cluster/cloud that KubeAI is installed into. You can modify a resource profile by setting custom helm values and runing <code>helm install</code> or <code>helm upgrade</code>. For example, if you are installing KubeAI on GKE you will need to set GKE-specific node selectors:</p> <pre><code># helm-values.yaml\nresourceProfiles:\n  nvidia-gpu-l4:\n    nodeSelector:\n      cloud.google.com/gke-accelerator: \"nvidia-l4\"\n      cloud.google.com/gke-spot: \"true\"\n</code></pre> <p>NOTE: See the cloud-specific installation guide for a comprehensive list of settings.</p>"},{"location":"how-to/configure-resource-profiles/#adding-additional-resource-profiles","title":"Adding additional resource profiles","text":"<p>If the preconfigured resource profiles do not meet your needs you can add additional profiles by appending to the <code>.resourceProfiles</code> object in the helm values file you use to install KubeAI.</p> <pre><code># helm-values.yaml\nresourceProfiles:\n  my-custom-gpu:\n    imageName: \"optional-custom-image-name\"\n    nodeSelector:\n      my-custom-node-pool: \"some-value\"\n    limits:\n      custom.com/gpu: \"1\"\n    requests:\n      custom.com/gpu: \"1\"\n      cpu: \"3\"\n      memory: \"12Gi\"\n</code></pre> <p>If you need to run custom model server images on your resource profile, make sure to also add those in the <code>modelServers</code> section:</p> <pre><code># helm-values.yaml\nmodelServers:\n  VLLM:\n    images:\n      optional-custom-image-name: \"my-repo/my-vllm-image:v1.2.3\"\n  OLlama:\n    images:\n      optional-custom-image-name: \"my-repo/my-ollama-image:v1.2.3\"\n</code></pre>"},{"location":"how-to/configure-resource-profiles/#next","title":"Next","text":"<p>See the guide on how to install models which includes how to configure the resource profile to use for a given model.</p>"},{"location":"how-to/configure-speech-to-text/","title":"Configure speech-to-text","text":"<p>KubeAI provides a Speech to Text endpoint that can be used to transcribe audio files. This guide will walk you through the steps to enable this feature.</p>"},{"location":"how-to/configure-speech-to-text/#enable-speech-to-text-model","title":"Enable Speech to Text model","text":"<p>You can create new models by creating a Model CRD object or by enabling a model from the model catalog.</p>"},{"location":"how-to/configure-speech-to-text/#enable-from-model-catalog","title":"Enable from model catalog","text":"<p>KubeAI provides predefined models in the <code>kubeai/models</code> Helm chart. To enable the Speech to Text model, you can set the <code>enabled</code> flag to <code>true</code> in your values file.</p> <pre><code># models-helm-values.yaml\ncatalog:\n  faster-whisper-medium-en-cpu:\n    enabled: true\n    minReplicas: 1\n</code></pre>"},{"location":"how-to/configure-speech-to-text/#enable-by-creating-model-crd","title":"Enable by creating Model CRD","text":"<p>You can also create a Model CRD object to enable the Speech to Text model. Here is an example of a Model CRD object for the Speech to Text model:</p> <pre><code>apiVersion: kubeai.org/v1\nkind: Model\nmetadata:\n  name: faster-whisper-medium-en-cpu\nspec:\n  features: [SpeechToText]\n  owner: Systran\n  url: hf://Systran/faster-whisper-medium.en\n  engine: FasterWhisper\n  resourceProfile: cpu:1\n</code></pre>"},{"location":"how-to/configure-speech-to-text/#usage","title":"Usage","text":"<p>The Speech to Text endpoint is available at <code>/openai/v1/transcriptions</code>.</p> <p>Example usage using curl:</p> <pre><code>curl -L -o kubeai.mp4 https://github.com/user-attachments/assets/711d1279-6af9-4c6c-a052-e59e7730b757\ncurl http://localhost:8000/openai/v1/audio/transcriptions \\\n  -F \"file=@kubeai.mp4\" \\\n  -F \"language=en\" \\\n  -F \"model=faster-whisper-medium-en-cpu\"\n</code></pre>"},{"location":"how-to/install-models/","title":"Install models","text":"<p>This guide provides instructions on how to configure KubeAI models.</p>"},{"location":"how-to/install-models/#installing-models-with-helm","title":"Installing models with helm","text":"<p>KubeAI provides a chart that contains preconfigured models.</p>"},{"location":"how-to/install-models/#preconfigured-models-with-helm","title":"Preconfigured models with helm","text":"<p>When you are defining Helm values for the <code>kubeai/models</code> chart you can install a preconfigured Model by setting <code>enabled: true</code>. You can view a list of all preconfigured models in the chart's default values file. </p> <pre><code># helm-values.yaml\ncatalog:\n  llama-3.1-8b-instruct-fp8-l4:\n    enabled: true\n</code></pre> <p>You can optionally override preconfigured settings, for example, <code>resourceProfile</code>:</p> <pre><code># helm-values.yaml\ncatalog:\n  llama-3.1-8b-instruct-fp8-l4:\n    enabled: true\n    resourceProfile: nvidia-gpu-l4:2 # Require \"2 NVIDIA L4 GPUs\"\n</code></pre>"},{"location":"how-to/install-models/#custom-models-with-helm","title":"Custom models with helm","text":"<p>If you prefer to add a custom model via the same Helm chart you use for installed KubeAI, you can add your custom model entry into the <code>.catalog</code> array of your existing values file for the <code>kubeai/models</code> Helm chart:</p> <pre><code># helm-values.yaml\ncatalog:\n  my-custom-model-name:\n    enabled: true\n    features: [\"TextEmbedding\"]\n    owner: me\n    url: \"hf://me/my-custom-model\"\n    resourceProfile: CPU:1\n</code></pre>"},{"location":"how-to/install-models/#installing-models-with-kubectl","title":"Installing models with kubectl","text":"<p>You can add your own model by defining a Model yaml file and applying it using <code>kubectl apply -f model.yaml</code>.</p> <p>If you have a running cluster with KubeAI installed you can inspect the schema for a Model using <code>kubectl explain</code>:</p> <pre><code>kubectl explain models\nkubectl explain models.spec\nkubectl explain models.spec.engine\n</code></pre>"},{"location":"how-to/install-models/#feedback-welcome-a-model-management-ui","title":"Feedback welcome: A model management UI","text":"<p>We are considering adding a UI for managing models in a running KubeAI instance. Give the GitHub Issue a thumbs up if you would be interested in this feature.</p>"},{"location":"installation/gke/","title":"Install on GKE","text":"TIP: Make sure you have enough quota in your GCP project. <p>Open the cloud console quotas page: https://console.cloud.google.com/iam-admin/quotas. Make sure your project is selected in the top left.</p> <p>There are 3 critical quotas you will need to verify for this guide. The minimum value here is assuming that you have nothing else running in your project.</p> Quota Location Min Value Preemptible NVIDIA L4 GPUs <code>&lt;your-region&gt;</code> 2 GPUs (all regions) - 2 CPUs (all regions) - 24 <p>See the following screenshot examples of how these quotas appear in the console:</p> <p></p> <p></p> <p></p>"},{"location":"installation/gke/#1-create-a-cluster","title":"1. Create a cluster","text":""},{"location":"installation/gke/#option-gke-autopilot","title":"Option: GKE Autopilot","text":"<p>Create an Autopilot cluster (replace <code>us-central1</code> with a region that you have quota).</p> <pre><code>gcloud container clusters create-auto cluster-1 \\\n    --location=us-central1\n</code></pre>"},{"location":"installation/gke/#option-gke-standard","title":"Option: GKE Standard","text":"<p>TODO: Reference gcloud commands for creating a GKE standard cluster.</p>"},{"location":"installation/gke/#2-install-kubeai","title":"2. Install KubeAI","text":"<p>Add KubeAI Helm repository.</p> <pre><code>helm repo add kubeai https://www.kubeai.org\nhelm repo update\n</code></pre> <p>Make sure you have a HuggingFace Hub token set in your environment (<code>HUGGING_FACE_HUB_TOKEN</code>).</p> <p>Install KubeAI with Helm.</p> <pre><code>cat &lt;&lt;EOF &gt; kubeai.yaml\nresourceProfiles:\n  nvidia-gpu-l4:\n    nodeSelector:\n      cloud.google.com/gke-accelerator: \"nvidia-l4\"\n      cloud.google.com/gke-spot: \"true\"\nEOF\n\nhelm upgrade --install kubeai kubeai/kubeai \\\n    -f ./kubeai.yaml \\\n    --set secrets.huggingface.token=$HUGGING_FACE_HUB_TOKEN \\\n    --wait\n</code></pre>"},{"location":"installation/gke/#3-optionally-configure-models","title":"3. Optionally configure models","text":"<p>Optionally install preconfigured models.</p> <pre><code>cat &lt;&lt;EOF &gt; kubeai-models.yaml\ncatalog:\n  llama-3.1-8b-instruct-fp8-l4:\n    enabled: true\nEOF\n\nhelm install kubeai-models kubeai/models \\\n    -f ./kubeai-models.yaml\n</code></pre>"},{"location":"reference/kubernetes-api/","title":"Kubernetes API","text":""},{"location":"reference/kubernetes-api/#packages","title":"Packages","text":"<ul> <li>kubeai.org/v1</li> </ul>"},{"location":"reference/kubernetes-api/#kubeaiorgv1","title":"kubeai.org/v1","text":"<p>Package v1 contains API Schema definitions for the kubeai v1 API group</p>"},{"location":"reference/kubernetes-api/#resource-types","title":"Resource Types","text":"<ul> <li>Model</li> </ul>"},{"location":"reference/kubernetes-api/#model","title":"Model","text":"<p>Model resources define the ML models that will be served by KubeAI.</p> Field Description Default Validation <code>apiVersion</code> string <code>kubeai.org/v1</code> <code>kind</code> string <code>Model</code> <code>metadata</code> ObjectMeta Refer to Kubernetes API documentation for fields of <code>metadata</code>. <code>spec</code> ModelSpec <code>status</code> ModelStatus"},{"location":"reference/kubernetes-api/#modelfeature","title":"ModelFeature","text":"<p>Underlying type: string</p> <p>Validation: - Enum: [TextGeneration TextEmbedding SpeechToText]</p> <p>Appears in: - ModelSpec</p>"},{"location":"reference/kubernetes-api/#modelspec","title":"ModelSpec","text":"<p>ModelSpec defines the desired state of Model.</p> <p>Appears in: - Model</p> Field Description Default Validation <code>url</code> string URL of the model to be served.Currently only the following formats are supported:For VLLM &amp; FasterWhisper engines: \"hf:///\"For OLlama engine: \"ollama:// <code>features</code> ModelFeature array Features that the model supports.Dictates the APIs that are available for the model. Enum: [TextGeneration TextEmbedding SpeechToText]  <code>engine</code> string Engine to be used for the server process. Enum: [OLlama VLLM FasterWhisper Infinity]  <code>resourceProfile</code> string ResourceProfile required to serve the model.Use the format \":\".Example: \"nvidia-gpu-l4:2\" - 2x NVIDIA L4 GPUs.Must be a valid ResourceProfile defined in the system config. <code>image</code> string Image to be used for the server process.Will be set from ResourceProfile + Engine if not specified. <code>args</code> string array Args to be added to the server process. <code>env</code> object (keys:string, values:string) Env variables to be added to the server process. <code>replicas</code> integer Replicas is the number of Pod replicas that should be activelyserving the model. KubeAI will manage this field unless AutoscalingDisabledis set to true. <code>minReplicas</code> integer MinReplicas is the minimum number of Pod replicas that the model can scale down to.Note: 0 is a valid value. Minimum: 0 Optional: {}  <code>maxReplicas</code> integer MaxReplicas is the maximum number of Pod replicas that the model can scale up to.Empty value means no limit. Minimum: 1  <code>autoscalingDisabled</code> boolean AutoscalingDisabled will stop the controller from managing the replicasfor the Model. When disabled, metrics will not be collected on server Pods. <code>targetRequests</code> integer TargetRequests is average number of active requests that the autoscalerwill try to maintain on model server Pods. 100 Minimum: 1  <code>scaleDownDelaySeconds</code> integer ScaleDownDelay is the minimum time before a deployment is scaled down afterthe autoscaling algorithm determines that it should be scaled down. 30 <code>owner</code> string Owner of the model. Used solely to populate the owner field in theOpenAI /v1/models endpoint.DEPRECATED. Optional: {}"},{"location":"reference/kubernetes-api/#modelstatus","title":"ModelStatus","text":"<p>ModelStatus defines the observed state of Model.</p> <p>Appears in: - Model</p> Field Description Default Validation <code>replicas</code> ModelStatusReplicas"},{"location":"reference/kubernetes-api/#modelstatusreplicas","title":"ModelStatusReplicas","text":"<p>Appears in: - ModelStatus</p> Field Description Default Validation <code>all</code> integer <code>ready</code> integer"},{"location":"reference/openai-api-compatibility/","title":"OpenAI API Compatibility","text":"<p>KubeAI provides an OpenAI API compatiblity layer.</p>"},{"location":"reference/openai-api-compatibility/#general","title":"General:","text":""},{"location":"reference/openai-api-compatibility/#models","title":"Models","text":"<pre><code>GET /v1/models\n</code></pre> <ul> <li>Lists all <code>kind: Model</code> object installed in teh Kubernetes API Server.</li> </ul>"},{"location":"reference/openai-api-compatibility/#inference","title":"Inference","text":""},{"location":"reference/openai-api-compatibility/#text-generation","title":"Text Generation","text":"<pre><code>POST /v1/chat/completions\nPOST /v1/completions\n</code></pre> <ul> <li>Supported for Models with <code>.spec.features: [\"TextGeneration\"]</code>.</li> </ul>"},{"location":"reference/openai-api-compatibility/#embeddings","title":"Embeddings","text":"<pre><code>POST /v1/embeddings\n</code></pre> <ul> <li>Supported for  Models with <code>.spec.features: [\"TextEmbedding\"]</code>.</li> </ul>"},{"location":"reference/openai-api-compatibility/#speech-to-text","title":"Speech-to-Text","text":"<pre><code>POST /v1/audio/transcriptions\n</code></pre> <ul> <li>Supported for Models with <code>.spec.features: [\"SpeechToText\"]</code>.</li> </ul>"},{"location":"reference/openai-api-compatibility/#openai-client-libaries","title":"OpenAI Client libaries","text":"<p>You can use the official OpenAI client libraries by setting the <code>base_url</code> to the KubeAI endpoint.</p> <p>For example, you can use the Python client like this: <pre><code>from openai import OpenAI\nclient = OpenAI(api_key=\"ignored\",\n                base_url=\"http://kubeai/openai/v1\")\nresponse = client.chat.completions.create(\n  model=\"gemma2-2b-cpu\",\n  messages=[\n    {\"role\": \"system\", \"content\": \"You are a helpful assistant.\"},\n    {\"role\": \"user\", \"content\": \"Who won the world series in 2020?\"},\n    {\"role\": \"assistant\", \"content\": \"The Los Angeles Dodgers won the World Series in 2020.\"},\n    {\"role\": \"user\", \"content\": \"Where was it played?\"}\n  ]\n)\n</code></pre></p>"},{"location":"tutorials/langchain/","title":"Using LangChain with KubeAI","text":"<p>LangChain makes it easy to build applications powered by LLMs. KubeAI makes it easy to deploy and manage LLMs at scale. Together, they make it easy to build and deploy private and secure AI applications.</p> <p>In this tutorial, we'll show you how to use LangChain with KubeAI's OpenAI compatible API. The beauty of KubeAI's OpenAI compatibility is that you can use KubeAI with any framework that supports OpenAI.</p>"},{"location":"tutorials/langchain/#prerequisites","title":"Prerequisites","text":"<p>A K8s cluster. You can use a local cluster like kind.</p>"},{"location":"tutorials/langchain/#installing-kubeai-with-gemma-2b","title":"Installing KubeAI with Gemma 2B","text":"<p>Run the following command to install KubeAI with Gemma 2B:</p> <pre><code>helm repo add kubeai https://www.kubeai.org\nhelm repo update\n\ncat &lt;&lt;EOF &gt; models-helm-values.yaml\ncatalog:\n  gemma2-2b-cpu:\n    enabled: true\n    minReplicas: 1\nEOF\n\nhelm install kubeai kubeai/kubeai \\\n    -f ./helm-values.yaml \\\n    --wait --timeout 10m\n\nhelm install kubeai-models kubeai/models \\\n    -f ./models-helm-values.yaml\n</code></pre>"},{"location":"tutorials/langchain/#using-langchain","title":"Using LangChain","text":"<p>Install the required Python packages: <pre><code>pip install langchain_openai\n</code></pre></p> <p>Let's access the KubeAI OpenAI compatible API locally to make it easier.</p> <p>Run the following command to port-forward to the KubeAI service: <pre><code>kubectl port-forward svc/kubeai 8000:80\n</code></pre> Now the KubeAI OpenAI compatible API is available at <code>http://localhost:8000/openai</code> from your local machine.</p> <p>Let's create a simple Python script that uses LangChain and is connected to KubeAI.</p> <p>Create a file named <code>test-langchain.py</code> with the following content: <pre><code>from langchain_openai import ChatOpenAI\n\nllm = ChatOpenAI(\n    model=\"gemma2-2b-cpu\",\n    temperature=0,\n    max_tokens=None,\n    timeout=None,\n    max_retries=2,\n    api_key=\"thisIsIgnored\",\n    base_url=\"http://localhost:8000/openai/v1\",\n)\n\nmessages = [\n    (\n        \"system\",\n        \"You are a helpful assistant that translates English to French. Translate the user sentence.\",\n    ),\n    (\"human\", \"I love programming.\"),\n]\nai_msg = llm.invoke(messages)\nprint(ai_msg.content)\n</code></pre></p> <p>Run the Python script: <pre><code>python test-langchain.py\n</code></pre></p> <p>Notice that we set base_url to <code>http://localhost:8000/openai/v1</code>. This tells LangChain to use our local KubeAI OpenAI compatible AP instead of the default OpenAI public API.</p> <p>If you run langchain within the K8s cluster, you can use the following base_url instead: <code>http://kubeai/openai/v1</code>. So the code would look like this: <pre><code>llm = ChatOpenAI(\n    ...\n    base_url=\"http://kubeai/openai/v1\",\n)\n</code></pre></p> <p>That's it! You've successfully used LangChain with KubeAI. Now you can build and deploy private and secure AI applications with ease.</p>"},{"location":"tutorials/langtrace/","title":"Deploying KubeAI with Langtrace","text":"<p>Langtrace is an open source tool that helps you with tracing and monitoring your AI calls. It includes a self-hosted UI that for example shows you the estimated costs of your LLM calls.</p> <p>KubeAI is used for deploying LLMs with an OpenAI compatible endpoint.</p> <p>In this tutorial you will learn how to deploy KubeAI and Langtrace end-to-end. Both KubeAI and Langtrace are installed in your Kubernetes cluster. No cloud services or external dependencies are required.</p> <p>If you don't have a K8s cluster yet, you can create one using kind or minikube. <pre><code>kind create cluster # OR: minikube start\n</code></pre></p> <p>Install Langtrace: <pre><code>helm repo add langtrace https://Scale3-Labs.github.io/langtrace-helm-chart\nhelm repo update\nhelm install langtrace langtrace/langtrace\n</code></pre></p> <p>Install KubeAI and wait for all components to be ready (may take a minute). <pre><code>helm repo add kubeai https://www.kubeai.org\nhelm repo update\nhelm install kubeai kubeai/kubeai --wait --timeout 10m\n</code></pre></p> <p>Install the gemma2-2b-cpu model:</p> <pre><code>cat &lt;&lt;EOF &gt; kubeai-models.yaml\ncatalog:\n  gemma2-2b-cpu:\n    enabled: true\n    minReplicas: 1\nEOF\n\nhelm install kubeai-models kubeai/models \\\n    -f ./kubeai-models.yaml\n</code></pre> <p>Create a local Python environment and install dependencies: <pre><code>python3 -m venv .venv\nsource .venv/bin/activate\npip install langtrace-python-sdk openai\n</code></pre></p> <p>Expose the KubeAI service to your local port: <pre><code>kubectl port-forward service/kubeai 8000:80\n</code></pre></p> <p>Expose the Langtrace service to your local port: <pre><code>kubectl port-forward service/langtrace-app 3000:3000\n</code></pre></p> <p>A Langtrace API key is required to use the Langtrace SDK. So lets get one by visiting your self hosted Langtace UI.</p> <p>Open your browser to http://localhost:3000, create a project and get the API keys for your langtrace project.</p> <p>In the Python script below, replace <code>langtrace_api_key</code> with your API key.</p> <p>Create file named <code>langtrace-example.py</code> with the following content: <pre><code># Replace this with your langtrace API key by visiting http://localhost:3000\nlangtrace_api_key=\"f7e003de19b9a628258531c17c264002e985604ca9fa561debcc85c41f357b09\"\n\nfrom langtrace_python_sdk import langtrace\nfrom langtrace_python_sdk.utils.with_root_span import with_langtrace_root_span\n# Paste this code after your langtrace init function\n\nfrom openai import OpenAI\n\nlangtrace.init(\n    api_key=api_key,\n    api_host=\"http://localhost:3000/api/trace\",\n)\n\nbase_url = \"http://localhost:8000/openai/v1\"\nmodel = \"gemma2-2b-cpu\"\n\n@with_langtrace_root_span()\ndef example():\n    client = OpenAI(base_url=base_url, api_key=\"ignored-by-kubeai\")\n    response = client.chat.completions.create(\n        model=model,\n        messages=[\n            {\n                \"role\": \"system\",\n                \"content\": \"How many states of matter are there?\"\n            }\n        ],\n    )\n    print(response.choices[0].message.content)\n\nexample()\n</code></pre></p> <p>Run the Python script: <pre><code>python3 langtrace-example.py\n</code></pre></p> <p>Now you should see the trace in your Langtrace UI. Take a look by visiting http://localhost:3000.</p> <p></p>"},{"location":"tutorials/weaviate/","title":"Weaviate with local autoscaling embedding and generative models","text":"<p>Weaviate is a vector search engine that can integrate seamlessly with KubeAI's embedding and generative models. This tutorial demonstrates how to deploy both KubeAI and Weaviate in a Kubernetes cluster, using KubeAI as the OpenAI endpoint for Weaviate.</p> <p>Why use KubeAI with Weaviate?</p> <ul> <li>Security and privacy: KubeAI runs locally in your Kubernetes cluster, so your data never leaves your infrastructure.</li> <li>Cost savings: KubeAI can run on your existing hardware, reducing the need for paying for embeddings and generative models.</li> </ul> <p>This tutorial uses CPU only models, so it should work even on your laptop.</p> <p>As you go go through this tutorial, you will learn how to:</p> <ul> <li>Deploy KubeAI with embedding and generative models</li> <li>Install Weaviate and connect it to KubeAI</li> <li>Import data into Weaviate</li> <li>Perform semantic search using the embedding model</li> <li>Perform generative search using the generative model</li> </ul>"},{"location":"tutorials/weaviate/#prerequisites","title":"Prerequisites","text":"<p>A Kubernetes cluster. You can use kind or minikube.</p> <pre><code>kind create cluster\n</code></pre>"},{"location":"tutorials/weaviate/#kubeai-configuration","title":"KubeAI Configuration","text":"<p>Let's start by deploying KubeAI with the models we want to use. Nomic embedding model is used instead of text-embedding-ada-002. Gemma 2 2B is used instead of gpt-3.5-turbo. You could choose to use bigger models depending on your available hardware.</p> <p>Create a file named <code>kubeai-model-values.yaml</code> with the following content: <pre><code>catalog:\n  text-embedding-ada-002:\n    enabled: true\n    minReplicas: 1\n    features: [\"TextEmbedding\"]\n    owner: nomic\n    url: \"ollama://nomic-embed-text\"\n    engine: OLlama\n    resourceProfile: cpu:1\n  gpt-3.5-turbo:\n    enabled: true\n    minReplicas: 1\n    features: [\"TextGeneration\"]\n    owner: google\n    url: \"ollama://gemma2:2b\"\n    engine: OLlama\n    resourceProfile: cpu:2\n</code></pre></p> <p>Note: It's important that you name the models as <code>text-embedding-ada-002</code> and <code>gpt-3.5-turbo</code> as Weaviate expects these names.</p> <p>Run the following command to deploy KubeAI and install the configured models: <pre><code>helm repo add kubeai https://www.kubeai.org &amp;&amp; helm repo update\n\nhelm install kubeai kubeai/kubeai\n\nhelm install kubeai-models kubeai/models \\\n    -f ./kubeai-model-values.yaml\n</code></pre></p>"},{"location":"tutorials/weaviate/#weaviate-installation","title":"Weaviate Installation","text":"<p>For this tutorial, we will use the Weaviate Helm chart to deploy Weaviate.</p> <p>Let's enable the text2vec-openai and generative-openai modules in Weaviate. We will also set the default vectorizer module to text2vec-openai.</p> <p>The <code>apiKey</code> is ignored in this case as we are using KubeAI as the OpenAI endpoint.</p> <p>Create a file named <code>weaviate-values.yaml</code> with the following content: <pre><code>modules:\n  text2vec-openai:\n    enabled: true\n    apiKey: thisIsIgnored\n  generative-openai:\n    enabled: true\n    apiKey: thisIsIgnored\n  default_vectorizer_module: text2vec-openai\nservice:\n  # To prevent Weaviate being exposed publicly\n  type: ClusterIP\n</code></pre></p> <p>Install Weaviate by running the following command: <pre><code>helm repo add weaviate https://weaviate.github.io/weaviate-helm &amp;&amp; helm repo update\n\nhelm install \\\n  \"weaviate\" \\\n  weaviate/weaviate \\\n  -f weaviate-values.yaml\n</code></pre></p>"},{"location":"tutorials/weaviate/#usage","title":"Usage","text":"<p>We will be using Python to interact with Weaviate. The 2 use cases we will cover are: - Semantic search using the embedding model - Generative search using the generative model</p>"},{"location":"tutorials/weaviate/#connectivity","title":"Connectivity","text":"<p>The remaining steps require connectivity to the Weaviate service. However, Weaviate is not exposed publicly in this setup. So we setup a local port forwards to access the Weaviate services.</p> <p>Setup a local port forwards to the Weaviate services by running: <pre><code>kubectl port-forward svc/weaviate 8080:80\nkubectl port-forward svc/weaviate-grpc 50051:50051\n</code></pre></p>"},{"location":"tutorials/weaviate/#weaviate-client-python-setup","title":"Weaviate client Python Setup","text":"<p>Create a virtual environment and install the Weaviate client: <pre><code>python -m venv .venv\nsource .venv/bin/activate\npip install -U weaviate-client requests\n</code></pre></p>"},{"location":"tutorials/weaviate/#collection-and-data-import","title":"Collection and Data Import","text":"<p>Create a file named <code>create-collection.py</code> with the following content: <pre><code>import json\nimport weaviate\nimport requests\nfrom weaviate.classes.config import Configure\n\n# This works due to port forward in previous step\nwith weaviate.connect_to_local(port=8080, grpc_port=50051) as client:\n\n    client.collections.create(\n        \"Question\",\n        vectorizer_config=Configure.Vectorizer.text2vec_openai(\n                model=\"text-embedding-ada-002\",\n                base_url=\"http://kubeai/openai\",\n        ),\n        generative_config=Configure.Generative.openai(\n            model=\"gpt-3.5-turbo\",\n            base_url=\"http://kubeai/openai\",\n        ),\n    )\n\n    # import data\n    resp = requests.get('https://raw.githubusercontent.com/weaviate-tutorials/quickstart/main/data/jeopardy_tiny.json')\n    data = json.loads(resp.text)  # Load data\n\n    question_objs = list()\n    for i, d in enumerate(data):\n        question_objs.append({\n            \"answer\": d[\"Answer\"],\n            \"question\": d[\"Question\"],\n            \"category\": d[\"Category\"],\n        })\n\n    questions = client.collections.get(\"Question\")\n    questions.data.insert_many(question_objs)\n    print(\"Data imported successfully\")\n</code></pre></p> <p>Create a collection that uses KubeAI as the openAI endpoint: <pre><code>python create-collection.py\n</code></pre> You should see a message <code>Data imported successfully</code>.</p> <p>The collection is now created and data is imported. The vectors are generated by KubeAI and stored in Weaviate.</p>"},{"location":"tutorials/weaviate/#semantic-search","title":"Semantic Search","text":"<p>Now let's do semantic search, which uses the embeddings. Create a file named <code>search.py</code> with the following content: <pre><code>import weaviate\nfrom weaviate.classes.config import Configure\n\n# This works due to port forward in previous step\nwith weaviate.connect_to_local(port=8080, grpc_port=50051) as client:\n    questions = client.collections.get(\"Question\")\n    response = questions.query.near_text(\n        query=\"biology\",\n        limit=2\n    )\n    print(response.objects[0].properties)  # Inspect the first object\n</code></pre></p> <p>Execute the python script: <pre><code>python search.py\n</code></pre></p> <p>You should see the following output: <pre><code>{\n  \"answer\": \"DNA\",\n  \"question\": \"In 1953 Watson &amp; Crick built a model of the molecular structure of this, the gene-carrying substance\",\n  \"category\": \"SCIENCE\"\n}\n</code></pre></p>"},{"location":"tutorials/weaviate/#generative-search-rag","title":"Generative Search (RAG)","text":"<p>Now let's do generative search, which uses the generative model (Text generation LLM). The generative model is run locally and managed by KubeAI.</p> <p>Create a file named <code>generate.py</code> with the following content: <pre><code>import weaviate\nfrom weaviate.classes.config import Configure\n\n# This works due to port forward in previous step\nwith weaviate.connect_to_local(port=8080, grpc_port=50051) as client:\n    questions = client.collections.get(\"Question\")\n\n    response = questions.generate.near_text(\n        query=\"biology\",\n        limit=2,\n        grouped_task=\"Write a tweet with emojis about these facts.\"\n    )\n\n    print(response.generated)  # Inspect the generated text\n</code></pre></p> <p>Run the python script: <pre><code>python generate.py\n</code></pre></p> <p>You should see something similar to this:</p> <p>\ud83e\uddec Watson &amp; Crick cracked the code in 1953!  \ud83e\udd2f They built a model of DNA, the blueprint of life. \ud83e\uddec \ud83e\udde0 Liver power! \ud83d\udcaa This organ keeps your blood sugar balanced by storing glucose as glycogen. \ud83e\ude78 #ScienceFacts #Biology</p>"},{"location":"tutorials/weaviate/#conclusion","title":"Conclusion","text":"<p>You've now successfully set up KubeAI with Weaviate for both embedding-based semantic search and generative tasks. You've also learned how to import data, perform searches, and generate content using KubeAI-managed models.</p>"}]}